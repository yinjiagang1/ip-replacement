<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>节点 IP/端口/备注 批量替换工具</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♻️</text></svg>">
    
    <style>
        :root {
            --primary-color: #2563eb;
            --bg-color: #f8fafc;
            --border-color: #e2e8f0;
            --text-color: #1e293b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.5;
            position: relative; /* 为 GitHub 图标定位 */
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            padding-right: 40px; /* 防止标题太长遮挡图标 */
        }

        /* 2. GitHub 图标样式 */
        .github-link {
            position: absolute;
            top: 20px;
            right: 20px;
            color: var(--text-color);
            transition: color 0.3s, transform 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .github-link:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }

        .github-link svg {
            width: 32px;
            height: 32px;
            fill: currentColor;
        }

        /* 移动端调整图标位置 */
        @media (max-width: 600px) {
            .github-link {
                top: 15px;
                right: 15px;
            }
            .github-link svg {
                width: 28px;
                height: 28px;
            }
        }

        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .box {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: Consolas, Monaco, "Courier New", monospace;
            font-size: 13px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        textarea:focus {
            outline: 2px solid var(--primary-color);
            border-color: transparent;
        }

        .controls {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #1d4ed8;
        }
        
        button.secondary {
            background-color: #64748b;
        }
        
        button.secondary:hover {
            background-color: #475569;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-wrapper input {
            width: 18px;
            height: 18px;
        }

        .hint {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 5px;
        }

        #resultArea {
            height: 300px;
            background-color: #fff;
        }
        
        .status {
            margin-left: auto;
            font-size: 0.9rem;
            color: var(--primary-color);
        }

        /* 3. 页脚样式 */
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-bottom: 20px;
            font-size: 0.85rem;
            color: #94a3b8;
            border-top: 1px solid #e2e8f0;
            padding-top: 20px;
        }
        
        .footer a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <!-- GitHub 项目地址 -->
    <a href="https://github.com/yinjiagang1/ip-replacement" target="_blank" class="github-link" title="在 GitHub 上查看源代码" aria-label="GitHub">
        <svg viewBox="0 0 16 16" version="1.1" aria-hidden="true">
            <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
    </a>

    <h1>♻️ 节点 IP / 端口 / ProxyIP / 备注 批量替换工具</h1>

    <div class="container">
        <div class="box">
            <label for="originalNode">1. 原始节点 (Vmess / Vless / Trojan)</label>
            <textarea id="originalNode" placeholder="粘贴单个 vless://, vmess:// 或 trojan:// 链接..."></textarea>
        </div>
        <div class="box">
            <label for="ipList">2. IP / 端口 / CIDR格式IP段 / 备注列表</label>
            <textarea id="ipList" placeholder="注意：如果输入的IP/域名没有指定端口，工具将自动设置为 443。
支持格式 (每行一个IP或逗号分隔)：
1.1.1.1 (仅替换IP)
1.1.1.1:8080 (替换IP和端口)
192.168.1.0/24 (生成该段所有IP)
192.168.1.0/24:2053 (该段所有IP+端口)
1.1.1.1:8080#新节点名称 (支持备注节点名称)
192.168.1.0/24#公司网段 (CIDR生成的IP都用此备注)
支持逗号分隔IP：
192.168.1.0 , 192.168.1.0:2053 , 192.168.1.0:2053#新节点名称

安全限制：防止生成太多卡死浏览器 (限制为 /16 大小)
"></textarea>
        </div>
    </div>

    <div class="controls">
        <label class="checkbox-wrapper" title="适用于 Cloudflare Worker / Edge Tunnel 等脚本">
            <input type="checkbox" id="proxyMode">
            <span>开启 ProxyIP 替换模式</span>
        </label>
        
        <button onclick="generate()">生成节点</button>
        <button class="secondary" onclick="copyResult()">复制结果</button>
        <span class="status" id="statusMsg"></span>
    </div>
    
    <p class="hint">
        * <b>注意：</b>开启ProxyIP替换模式之后会把ProxyIP一起替换为你输入的IP。
    </p>

    <div class="box" style="width: 100%;">
        <label for="resultArea">生成结果</label>
        <textarea id="resultArea" readonly placeholder="结果将显示在这里...
限制输出显示，防止浏览器崩溃（仅显示前 50000）"></textarea>
    </div>

    <p class="hint">
        * 列表支持：支持 <b>换行</b> 或 <b>逗号</b> 分隔。<br>
        * 备注功能：在 IP 后加 # 即可修改节点名称 (支持 Emoji)。<br>
        * CIDR 说明：仅支持 IPv4 CIDR，会自动展开为单个 IP，并保留备注。<br>
    </p>

    <!-- 新增页脚说明 -->
    <div class="footer">
        本工具部署在 Cloudflare Pages 上 | 代码由 <a href="https://gemini.google.com" target="_blank">Google Gemini</a> 生成
    </div>

    <script>
        // --- 辅助工具：UTF-8 安全的 Base64 ---
        function utf8_to_b64(str) {
            return window.btoa(unescape(encodeURIComponent(str)));
        }

        function b64_to_utf8(str) {
            return decodeURIComponent(escape(window.atob(str)));
        }

        // --- CIDR 处理工具函数 ---
        function ipToLong(ip) {
            return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0) >>> 0;
        }

        function longToIp(long) {
            return [
                (long >>> 24) & 255,
                (long >>> 16) & 255,
                (long >>> 8) & 255,
                long & 255
            ].join('.');
        }

        function getCidrIps(cidr) {
            try {
                const parts = cidr.split('/');
                if (parts.length !== 2) return null;
                
                const ip = parts[0];
                const bits = parseInt(parts[1], 10);
                
                if (bits < 0 || bits > 32) return null;

                const mask = ~(2 ** (32 - bits) - 1);
                const ipLong = ipToLong(ip);
                const start = (ipLong & mask) >>> 0;
                const end = (start + Math.pow(2, 32 - bits) - 1) >>> 0;
                
                if ((end - start) > 65536) {
                    console.warn(`CIDR range too large: ${cidr}, skipping expansion.`);
                    return null;
                }

                const ips = [];
                for (let i = start; i <= end; i++) {
                    ips.push(longToIp(i));
                }
                return ips;
            } catch (e) {
                console.error("CIDR Parse Error", e);
                return null;
            }
        }

        // --- 核心逻辑 ---

        function parseInputLine(line) {
            line = line.trim();
            if (!line) return null;
            
            let remark = null;
            let content = line;

            // 1. 提取备注 (处理 #)
            const hashIndex = line.indexOf('#');
            if (hashIndex > -1) {
                content = line.substring(0, hashIndex).trim();
                remark = line.substring(hashIndex + 1).trim();
            }

            // 2. 提取 IP 和 端口
            const lastColonIndex = content.lastIndexOf(':');
            let ipPart = content;
            let port = null;

            if (lastColonIndex > -1) {
                const portPart = content.substring(lastColonIndex + 1);
                // 简单校验端口是否为纯数字
                if (/^\d+$/.test(portPart)) {
                    ipPart = content.substring(0, lastColonIndex);
                    ipPart = ipPart.replace(/^\[|\]$/g, ''); 
                    port = portPart;
                }
            }

            // --- 如果没有指定端口，默认设置为 443 ---
            if (!port) {
                port = "443";
            }
            // ---------------------------------------------

            return { ipPart, port, remark };
        }

        function replaceProxyParam(str, newIp, newPort) {
            const targetPort = newPort || '443';
            const regexEncoded = /(proxyip%3D)(.*?)(%3A)(\d+)/gi;
            if (regexEncoded.test(str)) {
                return str.replace(regexEncoded, `$1${newIp}$3${targetPort}`);
            }
            const regexRaw = /(proxyip=)(.*?)(:)(\d+)/gi;
            if (regexRaw.test(str)) {
                return str.replace(regexRaw, `$1${newIp}$3${targetPort}`);
            }
            return str;
        }

        function processVmess(link, currentIp, currentPort, newRemark, isProxyMode) {
            try {
                const base64Str = link.replace('vmess://', '');
                const jsonStr = b64_to_utf8(base64Str);
                const config = JSON.parse(jsonStr);

                // 1. 替换 IP
                config.add = currentIp;

                // 2. 替换 主端口
                if (!isProxyMode && currentPort) {
                    config.port = parseInt(currentPort);
                }

                // 3. 替换 备注 (ps)
                if (newRemark) {
                    config.ps = newRemark;
                }

                // 4. ProxyMode 替换 Path
                if (isProxyMode) {
                    if (config.path) {
                        config.path = replaceProxyParam(config.path, currentIp, currentPort);
                    }
                }

                const newJson = JSON.stringify(config);
                return 'vmess://' + utf8_to_b64(newJson);
            } catch (e) {
                console.error(e);
                return "ERROR: Vmess 格式错误或 Base64 解析失败";
            }
        }

        function processUrlBased(link, currentIp, currentPort, newRemark, isProxyMode) {
            try {
                let result = link;

                // 正则：vless://uuid@IP:PORT...
                const mainRegex = /^([a-z]+:\/\/.*?@)(.*?)(:)(\d+)(.*)$/i;
                
                if (mainRegex.test(result)) {
                    result = result.replace(mainRegex, (match, p1, p2, p3, p4, p5) => {
                         const targetPort = currentPort ? currentPort : p4;
                         return `${p1}${currentIp}${p3}${targetPort}${p5}`;
                    });
                }

                if (isProxyMode) {
                    result = replaceProxyParam(result, currentIp, currentPort);
                }

                // 处理备注 (Hash)
                if (newRemark) {
                    // 移除旧的 hash (如果有)
                    const hashIdx = result.indexOf('#');
                    if (hashIdx > -1) {
                        result = result.substring(0, hashIdx);
                    }
                    // 添加新备注 (进行 URI 编码以防特殊字符)
                    result += '#' + encodeURIComponent(newRemark);
                }

                return result;
            } catch (e) {
                return "ERROR: URL 格式错误";
            }
        }

        function generate() {
            const originalNode = document.getElementById('originalNode').value.trim();
            const ipListText = document.getElementById('ipList').value.trim();
            const isProxyMode = document.getElementById('proxyMode').checked;
            const resultArea = document.getElementById('resultArea');
            const statusMsg = document.getElementById('statusMsg');

            if (!originalNode) {
                alert("请输入原始节点！");
                return;
            }
            if (!ipListText) {
                alert("请输入 IP 列表！");
                return;
            }

            // 支持换行符 (\n) 或 逗号 (,) 分隔
            // 使用正则拆分，map 去空，filter 去无效行
            const rawLines = ipListText.split(/[\n,]+/).map(l => l.trim()).filter(l => l);
            
            const results = [];

            let protocol = "";
            if (originalNode.startsWith('vmess://')) protocol = 'vmess';
            else if (originalNode.startsWith('vless://')) protocol = 'vless';
            else if (originalNode.startsWith('trojan://')) protocol = 'trojan';
            else {
                alert("不支持的协议头，请确保以 vmess://, vless:// 或 trojan:// 开头");
                return;
            }

            rawLines.forEach(line => {
                const inputObj = parseInputLine(line);
                if (!inputObj) return;

                const { ipPart, port, remark } = inputObj;
                let targetIps = [];

                if (ipPart.includes('/') && ipPart.indexOf('.') > -1) {
                    const expanded = getCidrIps(ipPart);
                    if (expanded && expanded.length > 0) {
                        targetIps = expanded;
                    } else {
                        targetIps = [ipPart];
                    }
                } else {
                    targetIps = [ipPart];
                }

                targetIps.forEach(ip => {
                    let newNode = "";
                    if (protocol === 'vmess') {
                        newNode = processVmess(originalNode, ip, port, remark, isProxyMode);
                    } else {
                        newNode = processUrlBased(originalNode, ip, port, remark, isProxyMode);
                    }
                    results.push(newNode);
                });
            });

            if (results.length > 50000) {
                statusMsg.textContent = `生成了 ${results.length} 个节点 (仅显示前 50000)`;
                resultArea.value = results.slice(0, 50000).join('\n');
            } else {
                resultArea.value = results.join('\n');
                statusMsg.textContent = `成功生成 ${results.length} 个节点`;
            }
            
            setTimeout(() => statusMsg.textContent = '', 5000);
        }

        function copyResult() {
            const resultArea = document.getElementById('resultArea');
            if (!resultArea.value) return;
            resultArea.select();
            document.execCommand('copy');
            const statusMsg = document.getElementById('statusMsg');
            statusMsg.textContent = "已复制到剪贴板";
            setTimeout(() => statusMsg.textContent = '', 2000);
        }
    </script>
</body>
</html>